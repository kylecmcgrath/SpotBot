\hypertarget{main_8cpp}{}\doxysection{src/main.cpp File Reference}
\label{main_8cpp}\index{src/main.cpp@{src/main.cpp}}
{\ttfamily \#include $<$Arduino.\+h$>$}\newline
{\ttfamily \#include $<$Print\+Stream.\+h$>$}\newline
{\ttfamily \#include $<$Wire.\+h$>$}\newline
{\ttfamily \#include $<$cstdlib$>$}\newline
{\ttfamily \#include \char`\"{}taskqueue.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}shares.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}task\+\_\+spot.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}task\+\_\+motor.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}task\+\_\+webserver.\+h\char`\"{}}\newline
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{main_8cpp_aeb497507cf17b4e667164726f1a9d2a9}\label{main_8cpp_aeb497507cf17b4e667164726f1a9d2a9}} 
Queue$<$ float $>$ {\bfseries vel\+\_\+queue} (2, \char`\"{}Velocities\char`\"{})
\item 
\mbox{\Hypertarget{main_8cpp_ade3f20ddb8c4231b3e62eff0d0ad8487}\label{main_8cpp_ade3f20ddb8c4231b3e62eff0d0ad8487}} 
Queue$<$ float $>$ {\bfseries vel\+\_\+r} (1000, \char`\"{}Right Velocities recorded over a rep\char`\"{})
\item 
\mbox{\Hypertarget{main_8cpp_a8859f96e040052dabce9802ed220cc33}\label{main_8cpp_a8859f96e040052dabce9802ed220cc33}} 
Queue$<$ float $>$ {\bfseries vel\+\_\+l} (1000, \char`\"{}Left Velocities recorded over a rep\char`\"{})
\item 
\mbox{\Hypertarget{main_8cpp_a8c76538b76010c6174b66a572fc24abe}\label{main_8cpp_a8c76538b76010c6174b66a572fc24abe}} 
Queue$<$ float $>$ {\bfseries timer} (1000, \char`\"{}Time over rep\char`\"{})
\item 
void \mbox{\hyperlink{main_8cpp_ad34c28b7e77e784ff26a914b58f53c77}{task\+\_\+\+IMU}} (void $\ast$p\+\_\+params)
\begin{DoxyCompactList}\small\item\em Task IMU grabs data from IMUs and converts into velocities to be used by other tasks. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{main_8cpp_a4fc01d736fe50cf5b977f755b675f11d}\label{main_8cpp_a4fc01d736fe50cf5b977f755b675f11d}} 
void {\bfseries setup} ()
\item 
\mbox{\Hypertarget{main_8cpp_afe461d27b9c48d5921c00d521181f12f}\label{main_8cpp_afe461d27b9c48d5921c00d521181f12f}} 
void {\bfseries loop} ()
\end{DoxyCompactItemize}
\doxysubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{main_8cpp_aedb4bc942fe3d8a504582625bf289f5a}\label{main_8cpp_aedb4bc942fe3d8a504582625bf289f5a}} 
const int {\bfseries MPU\+\_\+\+ADDR} = 0x68
\item 
\mbox{\Hypertarget{main_8cpp_acbae8a366271a5bd58009eb76239654f}\label{main_8cpp_acbae8a366271a5bd58009eb76239654f}} 
const int {\bfseries MPU\+\_\+\+ADDR2} = 0x69
\item 
\mbox{\Hypertarget{main_8cpp_a54119277ba8dabcc251f83a14ed9448a}\label{main_8cpp_a54119277ba8dabcc251f83a14ed9448a}} 
float {\bfseries calib\+\_\+const} = 1825.\+5
\item 
\mbox{\Hypertarget{main_8cpp_a15a86667ce13c0926bdb9e9b08ea5552}\label{main_8cpp_a15a86667ce13c0926bdb9e9b08ea5552}} 
float {\bfseries calib\+\_\+const2} = 1485.\+2
\item 
\mbox{\Hypertarget{main_8cpp_aac8fef4e3b3d833f16d5cef8ddce1ae1}\label{main_8cpp_aac8fef4e3b3d833f16d5cef8ddce1ae1}} 
float {\bfseries thresh} = 0.\+3
\item 
\mbox{\Hypertarget{main_8cpp_afc29fb7fadd39a1bc2e3c52532248689}\label{main_8cpp_afc29fb7fadd39a1bc2e3c52532248689}} 
float {\bfseries vel} = 0
\item 
\mbox{\Hypertarget{main_8cpp_a857c916d2df6a427df6e3c1595e4ba6e}\label{main_8cpp_a857c916d2df6a427df6e3c1595e4ba6e}} 
float {\bfseries vel2} = 0
\item 
\mbox{\Hypertarget{main_8cpp_a0c0ccd49af8109299e033b68e0b19a6f}\label{main_8cpp_a0c0ccd49af8109299e033b68e0b19a6f}} 
float {\bfseries vel\+\_\+init} = 0
\item 
\mbox{\Hypertarget{main_8cpp_a86c1bf9c2b8fb4a27b40d6275ba0a9ae}\label{main_8cpp_a86c1bf9c2b8fb4a27b40d6275ba0a9ae}} 
float {\bfseries vel\+\_\+init2} = 0
\item 
\mbox{\Hypertarget{main_8cpp_a71c6956105aa107794dae9065a4fd3f0}\label{main_8cpp_a71c6956105aa107794dae9065a4fd3f0}} 
uint8\+\_\+t {\bfseries IMU\+\_\+state} = 0
\item 
\mbox{\Hypertarget{main_8cpp_a08c44ef8317e8ddf8ebe49238123e9b9}\label{main_8cpp_a08c44ef8317e8ddf8ebe49238123e9b9}} 
uint16\+\_\+t {\bfseries tim\+\_\+count} = 0
\item 
\mbox{\Hypertarget{main_8cpp_ac196d59e44e091318ab3c8b5d5762c81}\label{main_8cpp_ac196d59e44e091318ab3c8b5d5762c81}} 
uint16\+\_\+t {\bfseries vel\+\_\+size} = 100
\item 
\mbox{\Hypertarget{main_8cpp_adb451e9225bdeefab97464b4a36105f7}\label{main_8cpp_adb451e9225bdeefab97464b4a36105f7}} 
int16\+\_\+t {\bfseries accelerometer\+\_\+x}
\item 
\mbox{\Hypertarget{main_8cpp_adb96ad7bf3b6ac95f63df85521770ef5}\label{main_8cpp_adb96ad7bf3b6ac95f63df85521770ef5}} 
int16\+\_\+t {\bfseries accelerometer\+\_\+y}
\item 
\mbox{\Hypertarget{main_8cpp_a3b8766131ada7b41d9cf4176d7ff9fc5}\label{main_8cpp_a3b8766131ada7b41d9cf4176d7ff9fc5}} 
int16\+\_\+t {\bfseries accelerometer\+\_\+z}
\item 
\mbox{\Hypertarget{main_8cpp_ada5e769dfe2804b5eaf4fd206cd4d7c4}\label{main_8cpp_ada5e769dfe2804b5eaf4fd206cd4d7c4}} 
int16\+\_\+t {\bfseries accelerometer\+\_\+z\+\_\+2}
\item 
\mbox{\Hypertarget{main_8cpp_a8dde3342979ed9986c16e356851a9c2a}\label{main_8cpp_a8dde3342979ed9986c16e356851a9c2a}} 
int16\+\_\+t {\bfseries gyro\+\_\+x}
\item 
\mbox{\Hypertarget{main_8cpp_a7c42f0111bf74679a9c36bca042bf011}\label{main_8cpp_a7c42f0111bf74679a9c36bca042bf011}} 
int16\+\_\+t {\bfseries gyro\+\_\+y}
\item 
\mbox{\Hypertarget{main_8cpp_aa7f04de51e63caab363ce9a56cd752bf}\label{main_8cpp_aa7f04de51e63caab363ce9a56cd752bf}} 
int16\+\_\+t {\bfseries gyro\+\_\+z}
\item 
\mbox{\Hypertarget{main_8cpp_a4af92569ea830250443045233c9bf5fb}\label{main_8cpp_a4af92569ea830250443045233c9bf5fb}} 
int16\+\_\+t {\bfseries temperature}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
This program includes task\+\_\+\+IMU and creates/runs the other tasks using Free\+RTOS. The program runs through tasks based off priority and timing in order to accomplish robot functionality. First data is collected using the IMUs whihc is sent to spot task to determine where the user is during the lift. This information determines whether the motor needs to be spun to save the user from being crushed.

\begin{DoxyAuthor}{Author}
Christian Clephan 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
12-\/2-\/22 
\end{DoxyDate}


\doxysubsection{Function Documentation}
\mbox{\Hypertarget{main_8cpp_ad34c28b7e77e784ff26a914b58f53c77}\label{main_8cpp_ad34c28b7e77e784ff26a914b58f53c77}} 
\index{main.cpp@{main.cpp}!task\_IMU@{task\_IMU}}
\index{task\_IMU@{task\_IMU}!main.cpp@{main.cpp}}
\doxysubsubsection{\texorpdfstring{task\_IMU()}{task\_IMU()}}
{\footnotesize\ttfamily void task\+\_\+\+IMU (\begin{DoxyParamCaption}\item[{void $\ast$}]{p\+\_\+params }\end{DoxyParamCaption})}



Task IMU grabs data from IMUs and converts into velocities to be used by other tasks. 

First transmision is made between MCU and I2C devices where the IMUs are \char`\"{}woken up\char`\"{}. Next, we combine the upper and lower byte values from the z acceleration data address to get the \char`\"{}tick\char`\"{} value of acceleration in z. This is then converted to m/s$^\wedge$2 and zero\textquotesingle{}d after some data analysis. The acceleration noise is set to zero and values are summed up in order to integrate. Velociteis are found through numerical integration and error propogation is somewhat mitigated and the values are put in their respective queues. ~\newline
 